usage: pygmentize [-l LEXER | -g] [-F FILTER[:options]] [-f FORMATTER]
                  [-O OPTION=value[,OPTION=value,...]] [-P OPTION=value]
                  [-o OUTPUTFILE] [-v] [-s] [-x]
                  [-S STYLE -f formatter | -L [WHAT [WHAT ...]] | -N FILENAME
                  | -C | -H NAME TYPE | -V | -h] [-a ARG]
                  [INPUTFILE]

Highlight an input file and write the result to an output file.

Main operation:
  -l LEXER      Specify the lexer to use. (Query names with -L.) If not given
                and -g is not present, the lexer is guessed from the filename.
  -g            Guess the lexer from the file contents, or pass through as
                plain text if nothing can be guessed.
  -F FILTER[:options]
                Add a filter to the token stream. (Query names with -L.)
                Filter options are given after a colon if necessary.
  -f FORMATTER  Specify the formatter to use. (Query names with -L.) If not
                given, the formatter is guessed from the output filename, and
                defaults to the terminal formatter if the output is to the
                terminal or an unknown file extension.
  -O OPTION=value[,OPTION=value,...]
                Give options to the lexer and formatter as a comma-separated
                list of key-value pairs. Example: `-O bg=light,python=cool`.
  -P OPTION=value
                Give a single option to the lexer and formatter - with this
                you can pass options whose value contains commas and equal
                signs. Example: `-P "heading=Pygments, the Python
                highlighter"`.
  -o OUTPUTFILE
                Where to write the output. Defaults to standard output.
  INPUTFILE     Where to read the input. Defaults to standard input.

Operation flags:
  -v            Print a detailed traceback on unhandled exceptions, which is
                useful for debugging and bug reports.
  -s            Process lines one at a time until EOF, rather than waiting to
                process the entire file. This only works for stdin, only for
                lexers with no line-spanning constructs, and is intended for
                streaming input such as you get from `tail -f`. Example usage:
                `tail -f sql.log | pygmentize -s -l sql`.
  -x            Allow custom lexers and formatters to be loaded from a .py
                file relative to the current working directory. For example,
                `-l ./customlexer.py -x`. By default, this option expects a
                file with a class named CustomLexer or CustomFormatter; you
                can also specify your own class name with a colon (`-l
                ./lexer.py:MyLexer`). Users should be very careful not to use
                this option with untrusted files, because it will import and
                run them.

Special modes - do not do any highlighting:
  -S STYLE -f formatter
                Print style definitions for STYLE for a formatter given with
                -f. The argument given by -a is formatter dependent.
  -L [WHAT [WHAT ...]]
                List lexers, formatters, styles or filters -- give additional
                arguments for the thing(s) you want to list (e.g. "styles"),
                or omit them to list everything.
  -N FILENAME   Guess and print out a lexer name based solely on the given
                filename. Does not take input or highlight anything. If no
                specific lexer can be determined, "text" is printed.
  -C            Like -N, but print out a lexer name based solely on a given
                content from standard input.
  -H NAME TYPE  Print detailed help for the object <name> of type <type>,
                where <type> is one of "lexer", "formatter" or "filter".
  -V            Print the package version.
  -h, --help    Print this help.
  -a ARG        Formatter-specific additional argument for the -S (print style
                sheet) mode.
